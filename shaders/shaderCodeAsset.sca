using namespace std;

// Entry point of the shader code asset
//
// @return color

#define PI 3.1415926535897932384626433832795

auto aspect(vec2 v)
{
  return v.y / v.x;
}

vec4 main(Texture2d tex, vec2 center, float pivot)
{
    auto p = fragment(getVertexTexCoord());
    
    auto c = center;
    
    auto cp = p - c;
    
    auto l_cp = length(cp);
    
    // aspect-corrected cp

    // c# = corner point
    // ac# = aspect of corner point
    auto ac = vec4(
      abs(aspect(p - vec2(0, 0))),
      abs(aspect(p - vec2(1, 0))),
      abs(aspect(p - vec2(1, 1))),
      abs(aspect(p - vec2(0, 1)))
    );

    // these are floats that represent bools if the point is in the specified quadrant
    auto bfs = vec4(
      cp.y > -cp.x * ac.w && cp.y >=  cp.x * ac.z, // +y
      cp.y >  cp.x * ac.x && cp.y <= -cp.x * ac.w, // +x
      cp.y < -cp.x * ac.y && cp.y <=  cp.x * ac.x, // -y
      cp.y <  cp.x * ac.z && cp.y >= -cp.x * ac.y  // -x
    );
   
    // closest points to the edge in each quadrant
    auto p0 = bfs.x * (1.0 - c.y) * vec2(cp.x / cp.y, 1);   // +y
    auto p1 = bfs.y * (0.0 - c.x) * vec2(1, cp.y / cp.x);   // +x
    auto p2 = bfs.z * (0.0 - c.y) * vec2(cp.x / cp.y, 1);   // -y
    auto p3 = bfs.w * (1.0 - c.x) * vec2(1.0, cp.y / cp.x); // -x
    
    // dot product gives us the nearest edge point in this quadrant
    auto ep = p0 + p1 + p2 + p3;

    // progress along cp -> np
    float t = abs(pivot - l_cp / length(ep));
    
    // point to sample from
    vec2 uv = (c + mix(vec2(0), ep, t));
    
    return tex.sample(uv);
}
